% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/telnyxapi.R
\name{tl_get_messages}
\alias{tl_get_messages}
\alias{tl_get_raw_messages}
\alias{tl_extract_raw_messages}
\title{Get SMS messages.}
\usage{
tl_get_messages(
  start_time,
  end_time = NULL,
  profile_ids = NULL,
  verbose = FALSE,
  v1_token,
  v1_user,
  params = NULL,
  incl_msg_body = TRUE,
  directions = list()
)

tl_get_raw_messages(key, verbose, ...)

tl_extract_raw_messages(js)
}
\arguments{
\item{start_time}{start time of report. Required. Must include the timezone.}

\item{end_time}{optional time for end of report. Must include the timezone.}

\item{profile_ids}{an optional vector of Messaging Profile ids to filter down to.}

\item{verbose}{defaults to FALSE.}

\item{v1_token}{Telnyx API v1 Token}

\item{v1_user}{Telnyx API v1 user, either an email or the preferred masked API user id.}

\item{params}{optional further arguments to pass into API query. Should be a named list.}

\item{incl_msg_body}{should the report include the text of the message?
Note that MMS have invalid JSON mixed with CSV problems. It's recommended you use \code{tl_get_raw_messages}
Which will make subsequent calls to the message endpoint to get a JSON list.
When using \code{tl_get_raw_messages} set this to \code{FALSE} to save yourself a headache.}

\item{directions}{Should be list() object. Allowed values are 'inbound' and 'outbound'}

\item{key}{API v2 Key}

\item{...}{Downstream params}

\item{js}{Output of \code{tl_get_raw_messages} to pass into \code{tl_extract_raw_messages}}
}
\description{
Get SMS messages from the MDR reports endpoint.
This reporting works as an asynchronous call to the report api and returns a CSV parsed into a data table using \code{fread}

See \href{https://developers.telnyx.com/docs/api/v1/reports}{here} for more details.
}
\details{
#' @title Get SMS messages via MDR beta endpoint
#'
#' @description
#' Get SMS messages from the MDR search endpoint.
#'
#' See \href{https://developers.telnyx.com/docs/api/v2/messaging/MDR-Search-Beta}{here} for more details.
#'
#' @param start_time start time of report. Required. Must include the timezone.
#' @param end_time end time for end of report. Required. Must include the timezone.
#' @param key Required. API v2 Key
#' @param profile_id optional. Messaging profile.
#' @param params. More params to pass down.
#'
#' @export
tel_getv2_messages <- function(
  start_time,
  end_time,
  key,
  profile_id = NULL,
  params     = NULL
){

  # Prepare Query
  qry <- list(
    'start_date' = format(lubridate::with_tz(start_time, 'UTC'), '%Y-%m-%dT%H:%M:%S+00:00'),
    'end_date'   = format(lubridate::with_tz(end_time, 'UTC'), '%Y-%m-%dT%H:%M:%S+00:00')
  )
  if(!is.null(profile_id)){
    qry[['outbound_profile_id']] = profile_id
  }
  qry <- c(qry, params)
  results <- list()
  curr_pg <- 5
  tot_pg <- 10
  while(curr_pg < tot_pg){
    pgs <- list(
      "page[number]" = curr_pg + 1,
      "page[size]"   = 25
    )
    r <- ..tl_getv2(
      ep     = stringr::str_glue('message_detail_records'),
      apikey = key,
      query = c(qry, pgs)
    )
    print(httr::content(r))
    httr::stop_for_status(r, stringr::str_glue("Paginating, at page {curr_pg +1} out of {tot_pg}"))
    res <- httr::content(r, 'parsed', encoding = 'UTF-8')
    results <- c(results, list(results))
    curr_pg <- res[['meta']][['page_number']]
    tot_pg <- res[['meta']][['total_pages']]
  }
  return(results)
}
}
